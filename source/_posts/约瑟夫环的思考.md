---
title: 约瑟夫环的思考
date: 2017-01-11 13:22:39
tags:
  - javascript
  - idea
---
![](http://cdn-public.imxuezi.com/joseph.jpg)

## 基本思路
首先创建一个 1～100 的数组。
```
[1,2,3,4,5,6,7,8,9,10,
11,12,13,14,15,16,17,18,19,20,
21,22,23,24,25,26,27,28,29,30,
31,32,33,34,35,36,37,38,39,40,
41,42,43,44,45,46,47,48,49,50,
51,52,53,54,55,56,57,58,59,60,
61,62,63,64,65,66,67,68,69,70,
71,72,73,74,75,76,77,78,79,80,
81,82,83,84,85,86,87,88,89,90,
91,92,93,94,95,96,97,98,99,100]
```

每隔 7 取一个数，剔除，第一次被剔除的数就是
```
[7,14,21,28,35,42,49,56,63,70,77,84,91,98]
```

剩下的数排列成新的数组
```
[1,2,3,4,5,6,8,9,10,
11,12,13,15,16,17,18,19,20,
22,23,24,25,26,27,29,30,
31,32,33,34,36,37,38,39,40,
41,43,44,45,46,47,48,50,
51,52,53,54,55,57,58,59,60,
61,62,64,65,66,67,68,69,
71,72,73,74,75,76,78,79,80,
81,82,83,85,86,87,88,89,90,
92,93,94,95,96,97,99,100]
```

剔除掉的最后一个数 98，往后还剩 99，100 两个数，在新的数组里，要排到头里继续算，因此新数组每个元素的游标都被前置了 2（因为第一次循环还剩2个数没算）,
所以在新数组里从第一个元素开始计算时，每个元素的游标都加 2，

第二次被剔除的数就是
```
[20,26,39,50,64,82,85]
```

此时剔除掉最后一个数时，还剩 85 未被计算，游标前置了 1，继续循环
```
[20,26,39,50,64,85] ~1
[20,26,39,50,64]    ~0
[20,39,50,64]       ~3
[20,39,50]          ~0
[39,50]             ~2
[50]
```
往后继续排除到只剩一个数 [50]

## 程序设计
定义一个 100 的数组
```js
var array = Array.from({length:100}).map((item,i)=>{return i+1;});
```

每隔 7 个数剔除，其实就是将游标(i)能整除 7 的元素剔除，因为数组的起始游标是 0，所以实际计算时，游标应该是(i+1),定义每次的起始基点为 left,
每次循环计算后都剩余几个数未计算，剩余的元素个数作为新的基点，所以计算后的实际游标就是(i+1+left),初始化基点 left 为 0,步长 step 为 7
```js
var left = 0, step = 7;
```
每次遍历后剔除掉满足游标的元素后，生成新的数组，算上基点重新遍历迭代，直到只剩 1 个元素
```js
var array = Array.from({length:100}).map((item,i)=>{return i+1;});
var left = 0, step = 7;
function goal(left, s, arr){
 console.log(arr);      // 打印每次的起始数组
 let length = arr.length // 数组长度
 if(length == 1) return console.log(arr); // 当只剩 1 个元素时，停止计算
 let ar = arr.filter((item, i)=>{
   return (i+1+left)%s != 0;  // 取出满足游标的元素
 });
 let dar = arr.filter((item, i)=>{
   return (i+1+left)%s == 0; // 取出满足游标与步长取模为 0 的元素
 });
 left += length-s*(length-ar.length); // 得到新的基点
 console.log(dar);      // 打印被剔除掉的元素
 console.log(left);     // 打印新的基点
 goal(left, s, ar);   // 将新的基点和新的数组迭代计算
}
goal(left, step, array);
```